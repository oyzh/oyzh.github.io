---
layout: post
title: 时间复杂度计算
excerpt: 递归函数的计算,用于程序的时间复杂度分析(算法导论第一部分)
---

<div id="outline-container-sec-1" class="outline-2">
<h2 id="sec-1"><span class="section-number-2">1</span> 时间复杂度</h2>
<div class="outline-text-2" id="text-1">
<p>
  假设输入问题的规模为 \(n\) ,定义时间复杂为 \(T(n)\) ,时间复杂度是关于输入规模的函数, 非递归定义的函数比较好估计,递归定义的函数需要技巧来估计. 常见的比如快排,归并排序等的时间函数都是递归定义的.
比如归并排序,当 \(n=1\) 时, \(T(n)=c\) ,当 \(n>1\) 时, \(T(n) = T(\lceil n/2 \rceil) + T(\lfloor n/2 \rfloor) + cn\) .
</p>

<p>
我们研究的是算法的 <b>渐近</b> 效率,即不用求的精确的 \(T(n)\) ,只需得到它的一个增长量级.运行时间是 \(n\) 的函数,我们可以定义
函数集合来使我们的时间函数属于某个函数集合.某个函数集合反映了一类时间复杂度,比如 \(\Theta(n)\) 表示时间复杂度是 \(n\) 的
函数集合.具体定义如下.
</p>
</div>
</div>

<div id="outline-container-sec-2" class="outline-2">
<h2 id="sec-2"><span class="section-number-2">2</span> 定义</h2>
<div class="outline-text-2" id="text-2">
</div><div id="outline-container-sec-2-1" class="outline-3">
<h3 id="sec-2-1"><span class="section-number-3">2.1</span> \(\Theta\) 记号</h3>
<div class="outline-text-3" id="text-2-1">
<p>
对于一个给定的函数 \(g(n)\) ,用 \(\Theta(g(n))\) 来表示以下的函数集合:
</p>

<p>
\(\Theta(g(n))\) = {\(f(n)\):存在正的常数\(c_1\), \(c_2\) 和 \(n_0\) ,使得对于所有\(n\ge n_0\),有 \(0\le c_1g(n) \le f(n) \le c_2g(n)\) }
</p>

<p>
即存在正的常数 \(c_1\) 和 \(c_2\) ,使得对于足够大的 \(n\) , 函数 \(f(n)\) 能 <b>夹入</b> \(c_1g(n)\) 与 \(c_2g(n)\) 之间,则 \(f(n)\) 属于集合 \(\Theta(g(n))\) .
</p>

<p>
这里的 \(g(n)\) 是 \(f(n)\) 的一个 <b>渐近紧确界</b> .
</p>
</div>
</div>
<div id="outline-container-sec-2-2" class="outline-3">
<h3 id="sec-2-2"><span class="section-number-3">2.2</span> \(O\) 和 \(o\) 记号</h3>
<div class="outline-text-3" id="text-2-2">
<p>
\(O(g(n))\) 表示的是渐近上界,它可能是紧确的,也可能不是,而 \(o(g(n))\) 一定不是上紧确的.
</p>

<p>
\(\O(g(n))\) = {\(f(n)\):存在正的常数 \(c\) 和 \(n_0\) ,使得对于所有 \(n \ge n_0\) ,有 \(0\le f(n) \le cg(n)\) }
</p>

<p>
\(\o(g(n))\) = {\(f(n)\):存在正的常数 \(c\) 和 \(n_0\) ,使得对于所有 \(n \ge n_0\) ,有 \(0\le f(n) < cg(n)\) }
</p>
</div>
</div>

<div id="outline-container-sec-2-3" class="outline-3">
<h3 id="sec-2-3"><span class="section-number-3">2.3</span> \(\Omega\) 和 \(\omega\) 记号</h3>
<div class="outline-text-3" id="text-2-3">
<p>
\(\Omega(g(n))\) 表示下界,可能是紧确的,也可能不是,而 \(\omega\) 一定不是紧确的.
</p>

<p>
\(\Omega (g(n))\) = {\(f(n)\):存在正的常数 \(c\) 和 \(n_0\) ,使得对于所有 \(n \ge n_0\) ,有 \(0 \le g(n) \le f(n)\) }
</p>

<p>
\(\omega (g(n))\) = {\(f(n)\):存在正的常数 \(c\) 和 \(n_0\) ,使得对于所有 \(n \ge n_0\) ,有 \(0 \le g(n) < f(n)\) }
</p>
</div>
</div>
</div>

<div id="outline-container-sec-3" class="outline-2">
<h2 id="sec-3"><span class="section-number-2">3</span> 计算</h2>
<div class="outline-text-2" id="text-3">
<p>
对于给定的递归的函数,我们可以计算它的时间复杂度的界.通常有3中方法(第四章):
</p>
<ol class="org-ol">
<li>猜测一个解,并用代入法求解
</li>
<li>用递归树方法求解
</li>
<li>用主方法求解
</li>
</ol>

<p>
方法1需要猜测一个解,然后代入递归式,假设小于n都成立,证明等于n时也成立,通常需要猜测一个好的解,而方法2可以用来猜测这个
解.用递归树有时可以得到精确的时间函数,这是我们可以判断得到的是一个紧的界.但有时由于树是非完全树等原因,通常我们会放宽条件,
得到的可能是一个不紧的界,这是就需要用代入法来验证.方法3可以解决一类递归式,但是还有很大一部分不能用这个公式.
</p>
</div>
</div>

<div id="outline-container-sec-4" class="outline-2">
<h2 id="sec-4"><span class="section-number-2">4</span> 证明中常用公式和实例</h2>
<div class="outline-text-2" id="text-4">
</div><div id="outline-container-sec-4-1" class="outline-3">
<h3 id="sec-4-1"><span class="section-number-3">4.1</span> 常用公式</h3>
<div class="outline-text-3" id="text-4-1">
</div><div id="outline-container-sec-4-1-1" class="outline-4">
<h4 id="sec-4-1-1"><span class="section-number-4">4.1.1</span> 取整公式</h4>
<div class="outline-text-4" id="text-4-1-1">
<p>
有些递归式带有取整符号,在用代入法求解时通常需要"凑",不如证明 \(O(n^2)\) 时可以转化成证明 \(O(n^2-1)\) ,这两个是一样的.
下面几个公式比较常用:
$$ \lceil \frac{n}{2} \rceil + 1 \ge \frac{n+1}{2}$$
$$ \lfloor \frac{n}{2} \rfloor + 1 \ge \frac{n+1}{2}$$
$$ \lceil \frac{n}{2} \rceil - 1 \le \frac{n-1}{2}$$
$$ \lfloor \frac{n}{2} \rfloor - 1 \le \frac{n-1}{2}$$
</p>
</div>
</div>

<div id="outline-container-sec-4-1-2" class="outline-4">
<h4 id="sec-4-1-2"><span class="section-number-4">4.1.2</span> 调和级数</h4>
<div class="outline-text-4" id="text-4-1-2">
<p>
调和级数也比较容易出现:
$$\Sigma_{i=1}^{n} \frac{1}{i} = \Theta(\ln{n})$$
</p>
</div>
</div>

<div id="outline-container-sec-4-1-3" class="outline-4">
<h4 id="sec-4-1-3"><span class="section-number-4">4.1.3</span> 阶乘的界</h4>
<div class="outline-text-4" id="text-4-1-3">
<p>
阶乘 \(n!\) 可以给出一个弱上界 \(n! \le n^n\) ,斯特林(Stirling)公式给出了一个更紧确的上下界:
斯特林(Stirling)近似公式:
$$n! = \sqrt{2 \pi n}(\frac{n}{e})^n(1+\Theta(\frac{1}{n}))$$
可以借助斯特林公式证明:
$$\lg(n!)=\Theta(n\lg n)$$
</p>
</div>
</div>

<div id="outline-container-sec-4-1-4" class="outline-4">
<h4 id="sec-4-1-4"><span class="section-number-4">4.1.4</span> 求根深度</h4>
<div class="outline-text-4" id="text-4-1-4">
<p>
在做递归树展开时,通常需要计算树的深度,一般的比较容易,而想 \(T(\sqrt{n})\) 的深度可以由以下估计,首先假设最后结果是2,证明如下:
$$ \sqrt[2^k]{n} = 2 $$
$$ n = 2^{2^k}$$
$$ k = \lg{\lg n} $$
求得深度k
</p>
</div>
</div>

<div id="outline-container-sec-4-1-5" class="outline-4">
<h4 id="sec-4-1-5"><span class="section-number-4">4.1.5</span> fibbonaci数</h4>
<div class="outline-text-4" id="text-4-1-5">
<p>
Fibbonaci有通项公式:
$$F_i = \frac{1}{\sqrt{5}}((\frac{1+\sqrt{5}}{2})^i - (\frac{1-\sqrt{5}}{2})^i)$$
由于后面那一项的绝对值小于1,所以更简单的公式:
$$F_i = round(\frac{1}{\sqrt{5}}(\frac{1+\sqrt{5}}{2})^i)$$
\(round\) 表示舍入到最近的整数,可以用加二分之一再向下取整实现.
</p>
</div>
</div>

<div id="outline-container-sec-4-1-6" class="outline-4">
<h4 id="sec-4-1-6"><span class="section-number-4">4.1.6</span> 量级比较</h4>
<div class="outline-text-4" id="text-4-1-6">
<p>
一些比较常见的量级比较:
</p>
<ul class="org-ul">
<li>对于 \(a>1\) 的实常量 \(a\) 和 \(b\) ,有:
</li>
</ul>
<p>
$$n^b = o(a^n)$$
</p>
<ul class="org-ul">
<li>对于任意常量 \(a>0\) :
</li>
</ul>
<p>
$$\lg^b{n} = o(n^a)$$
</p>
<ul class="org-ul">
<li>对于 \(1 \le a<b\) ,有:
</li>
</ul>
<p>
$$na^n = o(b^n)$$
</p>
</div>
</div>
</div>
<div id="outline-container-sec-4-2" class="outline-3">
<h3 id="sec-4-2"><span class="section-number-3">4.2</span> 实例</h3>
</div>
</div>
