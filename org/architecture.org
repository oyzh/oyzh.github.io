#+HTML_MATHJAX: align:"center" mathml:t path:"http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML" indent: 0em 
#+HTML_HEAD: <link rel="stylesheet" type="text/css" href="/css/style.css">
#+BEGIN_HTML
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({ TeX: { equationNumbers: {autoNumber: "AMS"} } });
</script>
#+END_HTML
#+OPTIONS: author:nil
#+OPTIONS: creator:nil
#+OPTIONS: timestamp:nil
#+OPTIONS: num:nil
-----
#+TITLE:计算机体系结构——量化研究方法
#+OPTIONS: toc:nil
* 计算机设计基本原理
处理器性能的改进不能再只依赖于指令级并行（ILP），而应更关注线程级并行（TLP）或是数据级并行（DLP），因为即使没有程序员的干预，编译器和硬件也能够充分利用指令级并行机制，相比起来，线程级并行和数据级并行属于显式并行，因为它们均要求程序员编写并行代码以改善系统性能。

一台计算机的实现包括两部分内容：组成和硬件。组成涵盖了计算机设计的更高层次，例如存储系统、存储器互联以及内部的处理器或CPU的设计。例如AMD Opteron 64和Intel Pentium 4拥有相同的指令集系统结构，但却有着完全不同的组成。两者都执行x86指令系统，但却有完全不同的流水线和Cache结构。

硬件是一台计算机的具体实现计算，包括具体的逻辑设计和封装设计。同一系列的计算机通常具有相同的指令集系统结构和几乎完全相同的组成，但它们的具体的硬件实现却不同。例如，Pentium 4和移动Pentium 4几乎是完全相同的，但两者提供了不同的时钟频率和存储系统，结果使得移动Pentium 4更适用于低端计算机。

在本书中，系统结构一词包含了上述计算机设计的所有三个方面——指令集系统结构、组成和硬件。

实现技术的发展趋势：
1. 性能的发展趋势：带宽优于时延。带宽或吞吐量指的是在给定事件内完成的工作总量。时延或响应时间则是指从事件开始到完成所需要的时间。
2. 晶体管性能与连线的规模。

从历史经验上来看，集成电路是计算机中最可靠的组件之一。虽然它们的管脚容易损坏，且在通信信道中常常会发生故障，但在芯片内部的差错率很低。为了更好的设计和构建计算机，通常把它分为不同的抽象层次。将计算机看成由许多子系统组成的，可以逐层分解细化直至单个晶体管。虽然某些故障常常出现，但大多数可以被局限在模块的单个组件上。因此，一个层面上某个模块的完全失效，反映在高层模块上仅仅被认为是组件的误差。这种层次的划分对于构建可靠的计算机是十分有益的。

计算机设计和分析时的指导性原则：
+ 采用并行性：系统级并行、指令间并行和数字设计层面上发掘并行。
+ 局部性原理：程序经常会重复使用它最近使用过的指令和数据。有两种类型的局部性原理：时间局部性原理和空间局部性原理。
+ 关注经常性事件：Amdahl定律。

IC：Instruction Count，指令数
CPI：Clock cycles Per Instruction，执行一条指令所需的平均时钟周期数

FP：浮点指令
FPSQR：浮点平方根指令

易犯错误：
+ 忽视Amdahl定律
+ 单点故障
+ 故障检测会降低可用性
谬误：
+ 处理器的成本在系统中占支配地位
+ 基准测试程序永远有效
+ 磁盘测定的平均故障事件为1200000小时或接近140年，因此在实际中磁盘永远不可能停止运转
+ 峰值性能体现实际性能

* 流水线
** 一个RISC指令系统的简单实现
每一条RISC指令的执行最多需要5个时钟周期。这5个时钟周期如下：
1. 取指令周期（IF）
2. 指令译码/读寄存器周期（ID）
3. 执行/有效地址周期（EX）
   + 访问存储器：通过ALU对基址寄存器和位移量进行加法运算形成有效地址。
   + 寄存器-寄存器ALU指令：ALU根据操作码对从寄存器堆中读取的数据进行运算。
   + 寄存器-立即数ALU指令：ALU根据操作码对从寄存器堆中读取的第一个操作数和扩展后的立即数进行运算。
4. 访问存储器（MEM）
5. 写回周期（WB）
   将结果写入寄存器堆。

** 经典的5段流水线RISC处理器
首先，流水中当IF和MEM同时执行时，实现方式是使用分开的指令和数据Cache，这样就不会有互相的。其次，寄存器堆在两个流水段中被使用：ID段，WB段。为了处理对同一个寄存器的读和写，我们在一个时钟周期的前半部分进行写寄存器操作，在该时钟周期的后半部分进行读寄存器操作。最后，为了在每一个时钟周期都能够启动一条新的指令，需要每个周期都对PC进行自加运算并写回结果，这项工作必须在IF段完成，以便为下一条指令做好准备。

尽管确保流水线中的指令在同一时间不会使用相同的硬件资源是非常重要的，但是我们还需要确保在流水线不同段中的指令不会相互影响。我们通过在连续的流水段中引入流水线寄存器来解决这个问题。

** 流水线的主要障碍——流水线冒险
*** 结构冒险
*** 数据冒险
*** 转移冒险
当一条转移指令执行时，它是否对PC加4是不确定的。如果一条转移指令把PC改写成它的目标地址，那么该转移称为选中转移，否则称为未选中转移。比如jmp后面一般带有一个地址，要么执行jmp下一条指令，要么执行jmp后面跟的地址，如果是执行jmp后面的地址，就是选中。
**** 减少流水线的转移代价
4种静态的方法：
+ 冻结或冲刷流水线，即在转移的目标地址确定之前保存或者删除所有紧随转移的指令。
+ 对所有转移都按未选中处理。因此必须注意在转移结果产生前不要改变机器的状态。
+ 预测转移被选中，一旦完成转移指令的译码并计算出目标地址后，就假设转移被选中，到目标地址取指令。
-----
#+BEGIN_HTML
<a href="http://oyzh.github.io">Back to Homepage</a>
<br>
<a href="http://github.com/oyzh">Github</a>
#+END_HTML
